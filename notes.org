* basics

variables
types of variables
math operations; sin, cos, sqrt, ... (what else is available?)

* parabolic movement

#+begin_src julia
  function airplane_motion(velocity, time, angle)
      g = 9.8
      x = velocity * cos(angle) * time
      y = velocity * sin(angle) * time - 0.5 * g * time^2
      return (x,y)
  end

  airplane_motion(0.5, .3, 0)
#+end_src

most of the time, our starting angle will be 0, also, we need a starting height. Let's set the function with default values

#+begin_src julia
  function airplane_motion(velocity, time, angle=0, height=1.5)
      g = 9.8
      x = velocity * cos(angle) * time
      y = height + velocity * sin(angle) * time - 0.5 * g * time^2
      return (x,y)
  end

  airplane_motion(0.5, .3)
#+end_src

To consider: Things we can change: velocity, angle. No the time.

The function should no return negative values for y... as if it hits the floor should stop.

#+begin_src julia
  function airplane_motion(velocity, time, angle=0, height=1.5)
      g = 9.8
      vx, vy = velocity * cos(angle), velocity * sin(angle)
      time_floor = (vy + sqrt(vy^2 + 2*g*height)) / g # Only the positive solution
      if time >= time_floor
          time = time_floor
      end
      x = vx  * time
      y = height + vy * time - 0.5 * g * time^2
      return (x,y)
  end

  airplane_motion(0.65, 1)
#+end_src



Let's create a number of variables to save the data for the plot

#+begin_src julia

  t_start = 0
  t_stop = 10
  dt = 1e-3
  # Create an array for all the times
  t = t_start:dt:t_stop
  nt = length(t)
  # create x and y
  x = zeros(nt)
  y = zeros(nt)

  velocity = 0.6
  for i in 1:nt
      x[i], y[i] = airplane_motion(velocity, t[i]);
  end

#+end_src


Lets' make a plot. First we need to install the library for making plots
#+begin_src julia
  ]
  add Plots
#+end_src

and plotting x, y

#+begin_src julia
  using Plots
  plot(x,y)
#+end_src

let's add some details

#+begin_src
plot(x, y, title="airplane movement"; xlabel="x", ylabel="y", linewidth=3) # label=""
#+end_src


* Then "convert" to julia


We can let julia to do the loop without us having to do it:
#+begin_src julia
position = airplane_motion.(velocity, t)
#+end_src




- we've not touched types yet!

- fix values: velocity, height
- plane: angle
- Then env: wind velocity, direction
- paper airplane: wing surface, attack angle,

* Tests?

* Questions
- How to use the second argument without specifying the first? i.e., change height
  - Mose: in the method defintion =function airplane_motion(velocity, time, angle=0, height=1.5)= we have four positional-only arguments, the third and forth (=angle= and =height=) being optional.
    Contrary to other languages (like Python and R(?)), function arguments can be either positional /or/ named keyword, but not both at the same time, so in practice with this single method definition there is no way to set the second optional argument (=height=) at the call-site without also specifying the first one (=angle=).
    There are ways to achieve this by defining extra methods if =angle= and =height= are annotated to have non-overlapping types, but this is probably a bit too advanced for this level.
- why =[0:10:100]= doesn't work as =collect= or =range=?
  - Mose: =[0:10:100]= creates a =Vector= whose only element is the object =0:10:100=.
    To create from =0:10:100= a =Vector= with elements =0=, =10=, ..., =1000=, like =collect(0:10:100)= would do, using the =[]= syntax you can "splat" =0:10:100=: =[0:10:100...]= (or use parentheses =[(0:10:100)...]= for good measure, in case you don't remember precedence rules, I never do).
    Note: splatting comes with a large-ish performance penalty, so when performance is relevant one may prefer a solution which doesn't involve splatting if possible, like =collect= in this specific case.
    I'm not sure about the reference to =range=: =range(0; stop=100, step=10)= would create exactly the same object as =0:10:100=, it's just an alternative to the =:= syntax, as it allows to specify a length instead of step or stop (the =:= syntax is always =start:step:stop=, with =step= being optional and defaulting to =1=.
- How to introduce =.=?
  - Mose: does the blogpost [[https://julialang.org/blog/2017/01/moredots/][More Dots: Syntactic Loop Fusion in Julia]] help for inspiration? The idea is that if you want to run a function element-wise on a vector/array, you can define the corresponding scalar function that you want to run on each element and then use the =.= to automatically "broadcast" the call to all elements of the input vector/array.
    Conceptually, the main proposition of the =.= is that it's a syntactic feature: you can write a scalar function and apply it on a vector/array argument at the call-site, instead of having to define a different method for the vector/array case.
-

* Sources
- [[http://www.lactea.ufpr.br/wp-content/uploads/2018/08/On_the_Aerodynamics_of_Paper_Airplanes.pdf][On the aerodynamics of paper airplanes]]
- [[http://www.stengel.mycpanel.princeton.edu/PaperPlane.html][Paper plane simulator]] (includes matlab code)
